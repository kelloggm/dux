\title{Dux: Automating Dependency Management}
\author{
        Martin Kellogg \\
        University of Washington
            \and
        Steven Lyubomirsky\\
        University of Washington
}


\documentclass[10pt,conference]{IEEEtran}

\usepackage{graphicx}
\usepackage{myref}
\usepackage{booktabs}
\usepackage{url}
\usepackage{listings}
\usepackage{color}
\usepackage{tikz}

\begin{document}

\maketitle

\lstset{language=bash}

\begin{abstract}

Research into build systems has focused on compiling and testing code, resulting
in high-quality tools for these activities. However, an often-overlooked step in
building code is \textit{dependency management}---the process of setting up the
environment so that the build can succeed. We argue that this process should be
treated as a separate problem from compiling and testing---the traditional domain
of build systems.

Instead, we present a \textit{build orchestration tool}, called
Dux, which focuses on the dependency management problem and then delegates to a
traditional build system for compiling and testing. Dux observes a successful
build for a project, and writes the information necessary to reproduce the build
to a configuration file. Further, Dux uses a content-addressed distributed file
system as a backing store for dependencies. When a project is observed to require
a dependency that is not in Dux's file system, it uploads a copy of the dependency
and indexes it by its hash. By reading the configuration file, Dux can reproduce 
the build of the project on a new system by checking the system for the required 
dependencies, and downloading any missing ones using the copy created when creating 
the configuration file, permitting easy, reproducible builds. Our present implementation,
which reads environmental variables and uses \texttt{strace} to track opened and
executed files during a build, is able to automatically reproduce builds of open-
source projects with external dependencies.

\end{abstract}

\section{Introduction}

                Modern build systems typically combine two functions:
setting up the environment and ensuring dependencies are available (\textit{build orchestration})
and compiling and testing (\textit{building}).
Existing tools are very good at the latter, but often fail at the former;
as an example, a study at Google found that more than 50\% of build failures
by real developers were caused by dependency errors~\cite{googlebuilderrors}.
We propose that by separating build orchestration from the process of actually
compiling and building software we can improve the reliability and reproducibility of builds.
We propose a specialized build orchestration tool which is responsible for setting up the environment
and providing dependencies, and then dispatches to a traditional build system.
By separating the two tools, we can achieve several advantages over traditional tools:
\begin{itemize}
\item{
\textit{Language independence:}
A specialized build orchestration tool can operate on any language.
Anecdotally, we have noticed that the best available build tools specialize
in a particular language (e.g. \texttt{ocamlbuild} or \texttt{gradle}).
A language-independent build orchestration tool can allow projects to retain
their natural build system while simplifying inter-language dependencies.
}
\item{
\textit{Automation:}
Modern industrial build systems (like Google's Bazel~\cite{blaze} or Facebook's Buck~\cite{buck}) provide fast,
reproducible builds---but at the cost of large, brittle configuration files.
By decoupling building from dependency management, we can automatically
discover dependencies and write configuration files automatically.
By combining this feature with the ability to dispatch to existing build systems,
our proposed tool makes migrating an existing project a push-button task.
}
\end{itemize}

\section{Technical Approach}

\subsection{Migration}

Migrating a project to use Dux is meant to be simple.
The developer demonstrates a build to Dux by providing a command (e.g. \texttt{ant build-and-test}),
and Dux executes that command in a sandbox, which records information about what the build does:
which files it accesses, which environment variables it reads, which programs it executes, etc.
Dux uses Linux's \texttt{strace} utility to perform this analysis---though this limits Dux to
Linux-based platforms, similar tools exist on other platforms: \texttt{dtruss} for Mac OSX or
\texttt{Process Monitor} for Windows. Extending Dux to operate on these platforms is future work.

Dux records the information it captures about the build into a configuration file.
To ensure that the same versions of artifacts are used during future builds,
Dux uses a hashing function to obtain a hash of each artifact required by the build.
Dux then communicates with a remote content-addressed file system~\cite{venti},
which is indexed by the hashes and contains artifacts.
If the artifact in question is not already in this remote file system, the migration tool uploads it.
The hashes (keys into the remote file system) are recorded in the configuration file.
Once the configuration file has been generated, it can be committed to version control.

\subsection{Building}

If a configuration file created by Dux is present, Dux queries the system for the dependencies required,
and downloads any that are not present.
It sets up the environment exactly as the configuration file specifies.
Then, it dispatches to the underlying build system to complete the build---Dux is specialized
to dependency management, and does not know or reason about actually building the software.
By separating these concerns, Dux can provide reproducible builds even for legacy software
with significant customized build logic, because migrating to use Dux requires only
demonstrating a correct build.

\section{Implementation}

We implemented Dux as a tool in Java 8, using Google Cloud Storage to handle the storage of dependencies.
Our development repository is public and may be accessed here: \url{https://github.com/kelloggm/dux/}.

\subsection{Recording a Build}
At the heart of the tool is a call to \texttt{strace}, which writes to a temporary file. We have \texttt{strace}
record calls to the \texttt{open}, \texttt{execve}, and \texttt{readlink} system calls, which are the relevant
ones for our purposes: \texttt{open} because any necessary configuration files that building tools use will
have to be opened to be read (it is sufficient to see which ones are opened without logging any of the
calls to \texttt{read}); \texttt{execve} because build managers generally delegate different build steps by
executing the necessarhy programs (such as compilers or scripts); and \texttt{readlink} to ensure that we
properly reproduce the directory structure of dependencies by tracking symbolic links. By logging these system
calls, Dux obtains a complete view of the files (both those read for information and executed) relevant to the
build process and thus identify all dependencies.

However, the build process may use information beyond that explicitly stored in configuration files; namely,
many builds rely on environment variables (especially \texttt{PATH}), so Dux must capture those as well
in spite of the fact that \texttt{strace} does not handle environmental variables. At present, Dux uses a
simple heuristic to decide which environmental varialbes to store in the absence of a trace: it parses
all environmental variables (searching for paths) and matches those paths against those logged by strace,
the intent being to find environmental variables specifying dependencies so that build tools can find them.
In the future, we may take a more robust approach by using another tool such as \texttt{ltrace} to trace
exactly which environmental variables are read during the build process (since environmental variables may
encode information other than paths).

Once Dux has saved the environmental variables deemed relevant and has a trace of system calls, it parses
the system calls to determine which files should be stored in the configuration and should be uploaded to
the store. Storing a file (or symbolic link) in the configuration means simply adding an entry to the
configuration file (\texttt{build.dux}), the entry consisting of a path to the dependency and a hash of the contents
(except in the case of a symbolic link). Note that we ``relativize'' file paths to avoid overspecifity; namely,
if a file path shares a prefix with the directory in which Dux is being invoked, we convert that path to
a relative path. This heuristic is to avoid having paths in the configuration be overly user-specific, as in the
case where a username forms part of a path; it is generally more useful to other users to have such paths be
relative to the project directory.

Because we only record \texttt{open}, \texttt{execve}, and \texttt{readlink} calls, all the
calls that arise in the recorded trace are potentially relevant, though we will only process a file once
and apply certain heuristics (optional) to reduce the workload. One heuristic is to disregard files located 
in the directory where Dux is being invoked, since these are ``project files'' and thus not dependencies
of the project. Another heuristic is to keep a ``blacklist'' of files that are often read during a build
but seldom convey relevant information or vary spuriously between machines or setups. By default, the
``blacklist'' consists only of \texttt{/proc/meminfo} (which contains information about the hardware's
capability), though the default blacklist may be expanded to include other low-level files once we have
run more builds and seen more examples of spurious ``dependencies''; the user may also create
a file \texttt{.duxignore} to supplement the default blacklist with further files or directories for
Dux to ignore when parsing \texttt{strace} output.

Once Dux has parsed the \texttt{strace} output and written the relevant files and symbolic links to
the local configuration file, Dux also uploads the logged dependencies to Google Cloud Storage (in a
bucket specified by the user) for future use. We implement our storage as a ``content-addressable
file system'' by naming files after their hashes, relying instead on the configuration file to recover
the path information for each file; this way, a user can retrieve the contents of a file simply by 
providing the hash logged in the configuration file.

\subsection{Validating and Reproducing a Build}
Reproducing a build is essentially the inverse process of that described above. Given a configuration file,
Dux checks that the environmental variables described within are set appropriately and checks that every
file listed in the configuration actually exists. If a file is missing, Dux pulls it in from Google Cloud
Storage using the hash in the configuration file. If a file is present but has a different hash from that
in the configuration, Dux warns the user but does not retrieve the file from cloud storage, since the file
could potentially contain important or system-specific information that is not safe to overwrite.

Once Dux has validated its configuration, the user may run the build. If all has been set correctly, including
symbolic links and environmental variables, the build should be able to proceed as before. There is an option
in Dux to have the tool take care of running the build as well; in this case, the tool is able to set all
logged environmental variables according to the configuration. (The tool is set up this way because a Java program
is not allowed to overwrite variables in its outer environment directly; a Java program may instead have a new
process be executed with an environment specially set.)

\section{Evaluation}

\section{Limitations}

Dux takes a rather reductive view of the build process, considering only the particular files that are read
and programs that are executed in one build on one system. As such, there are some dimensions to building that
Dux may fail to capture, such as logic that branches on different system configurations or present tools (e.g.,
having different possible builds depending on whether GCC or Clang is present on the system). In the case of
a build supporting different possible configurations, Dux may incorrectly label a machine as lacking proper
configuration when, in fact, the build may very well succeed. It is not obvious how Dux can be modified to address
this; a user would have to keep around different configuration files for different versions and know which
Dux configuration to pass around as appropriately.

Since Dux uploads dependencies without regard for their particular use, this may also lead to broken builds 
if it is applied on a system different from the one that was used to produce the configuration for a build, 
since Dux will pull in binaries that might have been compiled for a different system. A modification that
might hedge against this case would be keeping hashes of system metadata in configurations and knowing
that an executed binary from another system should likely not be pulled in to a different one.

\section{Related Work}

Several modern build systems include a dependency management strategy. Tools like
Maven~\cite{Maven}, Gradle~\cite{Gradle}, Bazel~\cite{blaze}, or Buck~\cite{buck}
are primarily systems for building and testing software, but each includes the
ability to specify dependencies manually in some kind of configuration file.
Ivy~\cite{Ivy} is exclusively a dependency management tool, but still requires
a manually written configuration file.
Unlike Dux's configuration files, which are automatically generated, the configuration
files for these tools use domain-specific languages that developers have to learn,
write, and maintain. Some tools (such as Bazel) also include sandboxing tools
that force the build to only use dependencies explicitly specified in the
configuration file.

Most recent advances in build technology have come from industry, not from
academia. Adams and McIntosh breifly cover build systems in their survey of
release engineering~\cite{adams2016modern}, in an effort to urge academics to
pay more attention to the work going on in industry. Cox et al. examined how
to prioritize updating dependencies, but did not attempt to fix build issues~\cite{cox2015measuring}.
McIntosh et al. built a classifier to determine when changes to the build
system would be necessary based on the changes introduced to source code~\cite{mcintosh2014mining}.
Seo et al. performed an empirical study at Google, and determined that more
than 50\% of build breakages were caused by dependency errors~\cite{googlebuilderrors}.
This is especially motivating for our work, since Google's Bazel build system
is considered the industry standard---and dependency issues are their most
common build error.

\section{Future Work}
A key question remains, even once Dux is implemented: how does Dux deal with
change, either in the environment or in the code it is building? We view building
the version of Dux we described here as the first step towards an adaptive
build system that can repair build scripts when they fail, using techniques
from the automated program repair literature. Existing program repair techniques
suffer from high false positive rates, in large part due to the unstructured
nature of the problem---with only a few (hundred? thousand?) test cases, it is
difficult to model all the correct behavior of a large C program~\cite{genprogisbadrinard}.
By contrast, the structured nature of a build configuration file and the relatively
small size of the change set make build script repair an attractive domain for
automated repair tools. By combining a tool like Dux with a build script repair
system, one can imagine a build tool that can correctly deploy software even in
the face of different dependency requirements or a different platform automatically,
making deploying software in new environments a much simpler process.

\section{References}

\begingroup
\renewcommand{\section}[2]{}%

% The following two commands are all you need in the initial runs of
% your .tex file to produce the bibliography for the citations in your
% paper.
\bibliographystyle{plain}
\bibliography{genprog-bib/merged}
% You must have a proper ``.bib'' file
% and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
\endgroup

\end{document}
