\title{Dux: Automating Dependency Management -- Windows Porting}
\author{
        Omeed Magness \\
        University of Washington
            \and
        Martin Kellogg \\
        University of Washington
}


\documentclass[10pt,conference]{IEEEtran}

\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage{myref}
\usepackage{booktabs}
\usepackage{url}
\usepackage{listings}
\usepackage{color}
\usepackage{tikz}

\begin{document}

\maketitle

\lstset{language=bash}

\begin{abstract}

The Dux build orchestration tool~\cite{dux} aimed to provide a guarantee that,
after observing a successful build of a project, it could reproduce this build on
any other machine just by saving a configuration file and dependency artifacts
to the cloud. However, Dux was limited to Linux because of its dependency on strace,
Linux's system call tracing utility.

In this report, we'll discuss modifications we made to Dux that allow it to run on
Windows. This primarily involved evaluating and selecting a suitable replacement 
for strace on Windows, rewriting a tracer and parser to target this new tool, and
rewriting some of the backend logic of Dux to handle the new trace format.

In the process, we refactored and decoupled a cross-platform (currently just Windows
and Linux) strace-tool like library which provides a consistent interface to a system
call tracing tool across those two platforms.

\end{abstract}

\section{Introduction}

The basic idea behind the Dux build orchestration tool~\cite{dux} is to trace
a demonstrated build command and observe the system calls that the build command is
making. From this list of system calls, it is possible to observe which files a
build is accessing. If these files, along with any relevant environment variables, 
are saved, it is possible to preserve the "execution context" that made that build
possible and recreate the build on another computer. 

Although the Dux tool itself is written in Java (making the majority of the code
automatically cross-platform), the tracing currently is done via Linux's strace utility. 
It would be good for Dux to be cross-platform, because the best tools that become
widely adopted in the community are always cross-platform (e.g. git, LaTeX, etc.).
In order to make Dux cross-platform, it is necessary to to find a suitable replacement
for strace on other platforms. 

This report discusses the effort to port Dux to Microsoft Windows. Section II
describes the process used to pick a replacement for strace on Windows. Section 
III discusses the implementation of the port. Section IV evaluates the end result
and discusses limitations and future work.

\section{Finding a Replacement for Strace} 

The first task involved in porting Dux to Windows was finding a suitable replacement
for strace. We evaluated many open-source command-line tools that claimed to be
similar to strace: DrMemory, the strace Cygwin port, StraceNT, etc. All had significant
limitations of some sort or another -- they could only be used on GUIs, could only be
used on command-line applications, etc. or were extremely unreliable and frequently
crashed. We noticed that all of these projects seemed to have been pretty old,
and development effort had been abandoned in recent years.

For that reason, we turned to Process Monitor, Microsoft's official process tracing 
utility, and the recommended solution on Windows. Process Monitor works quite well,
seems to be still actively developed, and produces very through event traces (system calls, 
registry accesses, etc.) for processes running on a system. Unfortunately, it is not
exactly meant for use like strace -- most operations must go through the GUI and,
in general, it traces all events across all processes on the system at once, not just 
an individual process. Although its advanced GUI filtering makes it possible to
filter by PID, it is hard to trace only the events of an arbitrary process (for
which you don't know the PID ahead of time).

So, although Process Monitor was clearly not exactly the tool we wanted, we made
it work because of its reliability and data quality. We found a way to extract a 
CSV file of event data from Process Monitor, and from there it was just a matter 
of parsing that data.

\begin{figure}
\includegraphics[width=\columnwidth]{DUX}
\caption{Dux's very cute logo. We did not create the image of the mother duck and ducklings; it is in the public domain.}
\end{figure}

\section{Implementation}

\subsection{Environment Setup}

The next step in porting Dux to Windows was setting up the development environment,
which entailed installing Google's Bazel build system, configuring a Google Cloud 
bucket (for use as a Dux file server), configuring credentials and service account
keys for that account, and integrating all of this with the Travis CI tool. The setup
turned out to be a nontrivial task, and we updated the README appropriately so
that future developers joining Dux will have a much smoother time.

\subsection{Removing the Strace Dependency}

After the environment was set up, we began the actual work of the project. To
begin with, this involved decoupling the strace dependence in Dux and refactoring the
existing strace-specific code to be more generic. We also moved the tracing code
to a separate package, because ideally, if a wrapper can be created around the
functionality provided by an strace-like tool on each platform, it is possible to
make a "cross-platform strace tool library" which could be generalized to projects
other than Dux as well.

Next, we began creating the batch scripts and configuration settings necessary to
extract the data from Process Monitor. Once we got this data out, parsing it was 
fairly simple, since it was a CSV file. The existing Dux parser was repurposed and
redesigned as an inheritance hierarchy to support parsing across multiple platforms.

\subsection{Filtering the Process Monitor Data}

With the Process Monitor data parsed out and represented as Java objects ("StraceCall"
objects), the data still needed to be filtered down. As mentioned before, because
Process Monitor's filters are fairly GUI-oriented, it was signifcantly easier to
do the event filtering after the data collection.

We generalized certain strace flags to work with Process Monitor as well, by using
the Builder pattern. For example, clients of our cross-platform strace-tool library
can now ask to trace subprocesses on a trace, and this will dispatch to \texttt{-f} on
Linux (the flag for strace to trace subprocesses) , or after-collection filtering
if on Windows. Because the data is all mixed together across processes in Windows,
we use a fixed point algorithm to determine subprocess PIDs.

Using our newly created strace tool library, we filtered down to system calls
that were only relevant to Dux (such as creating a file or process), and also
filtered by PID to only keep system calls originating from the desired process
to trace and its subprocesses. 

\subsection{Adjusting the Strace Call Interface}

Once we had a filtered set of StraceCall Java objects (see previous section)
representing the Process Monitor data, the next step was to use this data. We
wanted to provide a generic, cross-platform way, for a client to extact properties
about a sytem call, so we created some wrapper functions for these StraceCall
objects to determine if, for example, the call was an exec, was a file open, etc.

In other words, rather than hardcoding a call to strace, manually parsing, 
and inspecting properties of each StraceCall object, a client of our strace tool
library now just specifies some behavior they want from the trace
(e.g. tracing subprocess, or filtering to certain calls) and they will get back a list
of the traced calls, already parsed and filtered. And, to interact with these calls,
there is a platform independent interface. With this interface adjusted, the
backend of Dux could now be re-written to use the new interface. This essentially
completed an initial implementation of porting Dux to Windows!

\section{Evaluation, Limitations, and Future Work}

To evaluate the prototype of the port of Dux to Windows, we tried out a couple toy
examples. First, we installed a free Pascal compiler (fpc) 
\footnote{\url{https://www.freepascal.org/}} onto a Windows workstation,
and then compiled a "Hello World" program under Dux. Dux saved a configuration 
file and the necesssary dependencies to the cloud. We then went to another Windows
workstation without fpc installed, and asked Dux to check the build file for missing
dependencies. It downloaded the fpc binaries, set certain environment variables,
and then went on to compile the "Hello World" program. When ran, that program
produced the expected output.

We also did some stress testing and saw that Dux could bootstrap itself (i.e. trace
and record its own Google Bazel build). This involved uploading many hundreds
of files to the cloud. It was quite slow (because it uploaded so many files), 
and we are still evaluating if it was necessary to upload as many dependencies as
we did. This behavior might be due to the fact that the Process Monitor output format
makes it tricky to handle file system links. Adjusting this issue is future work.

The Windows port of Dux suffers from many of the same limitations as the original
Dux project -- in particular, the static versioning. This project also has added
the limitation that a Dux build file for a project on Windows will almost certainly
not be able to reconstruct the environment on Linux properly, and vice versa,
simply due to differing binaries. We see this port as useful for the sake of one
Windows developer demonstrating a build to another Windows developer, or, as 
with the original  version of Dux, one Linux developer demonstrating a build to 
another Linux devloper. This hopefully is a common-enough scenario, with
developers on a project conforming to some standard environment. 

As an orthogonoal point, our "cross-platform strace-tool" library is truly meant to be
cross-platform. In future work, we'd like to expand and generalize the interface of this 
strace tool library so that it can be released as its own tool. Right now, its
functionality is fairly specific to the use case which Dux requires.

\section{References}

\begingroup
\renewcommand{\section}[2]{}%

% The following two commands are all you need in the initial runs of
% your .tex file to produce the bibliography for the citations in your
% paper.
\bibliographystyle{plain}
\bibliography{genprog-bib/merged}
% You must have a proper ``.bib'' file
% and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
\endgroup

\end{document}
